/*
10. 데이터 모델링
10.1 데이터 모델링이란
*/
-- 무엇? 현실 세계를 추상화(모형화)하여 데이터로 만드는 것
-- 현실 세계의 데이터를 데이터베이스로 구조화하는 과정
-- 어떤 데이터를 저장하고 어떻게 관계를 맺을지를 설계하는 작업
-- 데이터베이스를 만들기 위해서 기본 설계도를 그리는 것
-- 목표는? 데이터의 일관성, 중복 최소화, 효율적인 관리

-- 예: 쇼핑몰 사이트 기획
-- - 고객은 누구? -> 고객 테이블
-- - 어떤 상품을 판매? -> 상품 테이블
-- - 주문은 어떻게 받을지? -> 주문 테이블
-- - 결제는 어떻게 처리할지? -> 결제 테이블
-- => 분석을 해서 어떤 데이터가 필요한지 데이터 모델을 만드는 작업


-- 데이터 모델을 꼭 만들어야 할까? 그냥 그때그때 바로바로 데이터베이스를 만들어 나가면?
-- 집에 비유를 하면
-- 강아지집을 만들 때는 굳이 뭐 설계도 없어도 OK
-- 고층 빌딩을 지을 때는 그때그때 만들다 문제가 생기면 위험이 큼
-- 즉, 설계도 없는 집은 규모가 커질수록 많은 리스크를 지님
-- 마찬가지로 프로젝트 또는 서비스의 규모가 커질수록 설계 없이는 문제가 발생할 가능성이 큼

-- 데이터 모델링의 이점
-- 1) 비즈니스 요구사항 반영
-- - 실제 비즈니스 운영 방식에 맞게 DB를 설계
-- - 비즈니스가 지향하는 목표에 효과적

-- 2) 의사소통에 기여
-- - 전문가와 비전문가 사이에서 소통의 도구
-- - 지속적인 공유와 피드백으로 협업을 도움

-- 3) 데이터 무결성 보장
-- - 분석/설계 과정을 거치며 신뢰할 수 있는 구조와 관계를 정의
-- - 다양한 제약 조건 및 규칙을 사용해 오류 및 왜곡 방지

-- 4) 성능 최적화에 도움
-- - (설계 단계에서) 핵심 데이터를 남기고 무의미한 데이터는 제거
-- - 최소 비용으로 최대 성능을 낼 수 있게 도움
-- - 설계도를 통해 시뮬레이션

-- 5) 유연한 확장 가능
-- - 추가 확장성을 미리 고려한 모델 설계
-- - 새로운 요구사항에도 유연하게 조정 가능

-- 6) 비용 절감 가능
-- - 설계 단계를 통한 잠재적 문제를 식별
-- - 개발 및 운영 단계에서 발생할 문제를 예방

-- 데이터 모델링 3단계
-- 데이터 모델링은 개념적 -> 논리적 -> 물리적 순으로 진행
-- 위 3단계를 거쳐 최종 데이터베이스를 구현

-- 1) 개념적 데이터 모델링
-- 현실 세계를 구성하는 주요 개체(엔티티, entity)와 그들 간 관계(relation)를 정의
-- 전문가/비전문가 모두를 위한 개념적 설계를 목표
-- '무엇'을 만들 것인가에 집중

-- 예: 쇼핑몰 사이트
-- 엔티티: 사용자, 주문, 결제, 상품 -> Table이 될 대상들
-- 관계: 주문하다, 결제하다, 장바구니에 담다 로 연결

-- 2) 논리적 데이터 모델링
-- 개념적 데이터 모델의 세부 내용(속성 등)을 정의
-- 뼈대에 살을 붙이는 과정(점진적 반복 검증)
-- '어떻게' 만들 것인가에 집중

-- 예:
-- 엔티티의 속성 및 식별자 정의
-- 관계의 유형 정의(1:1, 1:N, N:M)
-- 데이터의 중복 제거
-- 정규화(데이터가 잘 만들어졌는지 검증)
 


-- 3) 물리적 데이터 모델링
-- 논리적 데이터 모델을 특정 DBMS에 최적화
-- '높은 성능과 적은 비용'으로 어떻게 구현할 것인가에 초점

-- 예:
-- 테이블명, 컬럼명 정의
-- 기본키 및 외래키 지정
-- 자료형, 제약 조건 등을 설정



-- Quiz
-- 1. 다음 설명이 맞으면 O, 틀리면 X를 순서대로 입력하시오.
-- ① 데이터 모델링이란 현실 세계의 사물이나 현상을 추상화해 데이터 간 구조와 관계를 정의한 것이다. (  )
-- ② 데이터 모델링할 때는 비즈니스 요구사항은 무시하고 데이터 구조만 고려한다. (  )
-- ③ 데이터 모델링하면 추후 시스템 확장과 변화에 쉽게 적응할 수 있다. (  )
-- ④ 개념적 데이터 모델링 단계에서는 요구사항 분석을 통해 핵심 엔티티와 이들 간 관계를 정의한다. (  )
-- ⑤ 논리적 데이터 모델링 단계에서는 개념적 데이터 모델링의 결과 만들어진 데이터 모델의 세부 내용을 정의한다. (  )
-- ⑥ 물리적 데이터 모델링 단계에서는 논리적 데이터 모델링의 결과 만들어진 데이터 모델을 특정 DBMS에 맞게 최적화한다.(  )

-- 정답: O, X, O, O, O, O


/*
	10.2 데이터 모델의 구성 요소 3가지(엔티티, 속성, 관계)
*/
-- 1. 엔티티(entity)
-- 데이터베이스로 관리하려는 핵심 대상(테이블화 될 대상)
-- 비즈니스에 실제로 존재하거나, 개념적으로 중요한 것

-- 예: 쇼핑몰의 엔티티
-- 사용자 엔티티, 주문 엔티티, 결제 엔티티, 상품 엔티티

-- 엔티티와 연관된 용어 정리
-- 엔티티: 설계도 상에서의 명칭
-- 테이블: 엔티티를 실제 데이터베이스에 구현한 것(행과 열로 구성)
-- 인스턴스: 엔티티의 실제 데이터, 테이블에 저장된 행 단위 데이터

-- 2. 속성(attribute)
-- 엔티티의 특성이나 정보를 나타내는 항목
-- 여러 속성이 모여 하나의 엔티티를 구성
-- 테이블의 컬럼으로 구현될 정보

-- 예: 상품 엔티티의 속성
-- ID, 상품명, 가격, 상품 유형 등

-- 속성 중 식별자(identifier) 대해
-- 엔티티의 각 인스턴스를 고유하게 식별하기 위한 특별 속성(예: 기본키, 주민등록번호)
-- 식별자는 다음 4가지 조건을 만족해야 함(기본키의 특징 때 이미 배웠음, 암기X)
-- • 유일성(uniqueness): 특정 엔티티의 인스턴스 구분을 위해, 중복되지 않는 고유값을 지님
-- • 불변성(immutability): 한번 정해진 값은 변경 불가
-- • 존재성(existence): 값이 반드시 존재해야 함
-- • 최소성(minimality): 최소한의 속성으로 모든 인스턴스를 구분해야 함

-- 주요 식별자
-- • 기본 식별자(primary identifier): 엔티티 내 모든 인스턴스를 구분 가능(예: 사용자 엔티티의 id)
-- • 대체 식별자(alternate identifier): 기본 식별자는 아니지만, 그 역할도 가능(예: 사용자 엔티티의 email)
-- • 외래 식별자(foreign identifier): 다른 엔티티의 기본 식별자를 참조(예: 주문 엔티티의 사용자 ID)

-- 식별자(identifier)와 키(key)는 같은 의미를 지님
-- 모델링 단계에서는 식별자로 데이터베이스 구현 단계에서는 키로 부름

CREATE TABLE users (
	id INTEGER, -- 기본키
	email VARCHAR(100) NOT NULL UNIQUE, -- 대체키(NOT NULL UNIQUE): 데이터베이스에서 후보키 중 기본키로 선택되지 않은 키
	name VARCHAR (50),
	PRIMARY KEY (id)
);
CREATE TABLE orders (
	id INTEGER, -- 기본키
	status VARCHAR(50), 
	created_at DATETIME, 
	user_id INTEGER, -- 외래키
	PRIMARY KEY (id),
	FOREIGN KEY (user_id) REFERENCES users(id)
);

-- (참고) 후보키: 
-- 테이블에서 행을 유일하게 식별할 수 있는 모든 컬럼(또는 컬럼 집합)
-- UNIQUE + NOT NULL 조건을 만족해야 함
-- [후보키]
--  ├── 기본키       <- 후보키 중 대표로 선택된 하나의 키
--  └── 대체키(들)   <- 기본키로 선택되지 않은 나머지 후보키들

-- 3. 관계(relationship)
-- 두 엔티티 간 연결된 방식을 나타냄
-- 카디널리티를 통해 관계를 구분
-- 카디널리티(cardinality): 특정 엔티티의 인스턴스가 다른 엔티티의 몇 개의 인스턴스와 연결되는가

-- 예: 1, N, M을 카디널리티라 부름
-- 일대일 관계: 국가(1) ----- (1)수도
-- 일대다 관계: 팀(1) ----- (N)선수
-- 다대다 관계: 주문(N) ----- (M)상품

-- 4. ER 다이어그램(entity-relationship diagram)
-- 데이터 모델을 정의하는 시각적 도구
-- 엔티티, 속성, 관계를 기호로 그린 것

-- 선택성(optionality)에 대해
-- 관계가 필수적인지, 선택적인지를 표시
-- 필수적 관계 구현은 외래키에 NOT NULL 제약 조건을 설정
-- NOT NULL이 없으면 선택적 관계가 됨

-- 예시1
-- 사용자는 프로필을 가지지 않을 수도 있고, 가진다면 최대 1개 가질 수 있다. (0~1)
-- 프로필은 사용자와 관계를 맺는데, 반드시 가져야 한다. (1~1)

-- 예시2
-- 사용자는 주문을 안 할 수도 있지만, 주문을 한다면 여러 개의 주문을 할 수 있다. (0~N)
-- 주문은 특정 사용자 참조할 수도 있고, 또는 참조하지 않을 수도 있다. 즉, 비회원인 경우에도 주문을 할 수 있다. (0~1)

-- Quiz
-- 2. 다음 빈칸에 들어갈 용어를 순서대로 고르시오.
-- ① __________: 비즈니스에서 중요 대상을 모형화한 것으로 데이터베이스로 구현했을 때 테이블이 됨
-- ② __________: 엔티티의 실제 데이터로, 테이블에 저장된 행 단위의 데이터
-- ③ __________: 엔티티의 특성이나 정보를 나타내는 항목으로 데이터베이스로 구현했을 때 칼럼이 됨
-- ④ __________: 엔티티의 한 인스턴스가 다른 엔티티의 몇 개 인스턴스와 연결되는지를 나타내는 개념
-- ⑤ __________: 엔티티 내에서 각 인스턴스를 고유하게 식별하는 속성 또는 속성의 조합

-- (ㄱ) 속성
-- (ㄴ) 엔티티
-- (ㄷ) 기본 식별자
-- (ㄹ) 카디널리티
-- (ㅁ) 인스턴스

-- 정답: ㄴㅁㄱㄹㄷ


-- 3. 다음 ER 다이어그램에 대한 설명으로 옳지 않은 것을 고르세요.
-- (ch10_quiz3.png 참고)

-- ① 학생 엔티티의 기본키는 'ID'이다.
-- ② 강의 엔티티의 속성은 'ID'와 '강의명'이다.
-- ③ 학생 엔티티와 강의 엔티티는 필수적 다대다 관계이다.
-- ④ 학생 인스턴스는 선택적으로 등록 인스턴스를 여러 개 가질 수 있다.
-- ⑤ 등록 인스턴스는 반드시 학생 인스턴스와 강의 인스턴스를 각각 1개씩 참조해야 한다.

-- 정답: 3 -> 선택적, NOT NULL 주면 필수적인 관계


/*
	10.3 데이터 모델링 실습: 쇼핑몰 DB
*/
-- 다음 요구사항을 참고해 데이터 모델링(개념적 -> 논리적 -> 물리적)을 거쳐 최종 데이터베이스를 구현해 보자!

-- 요구사항
-- 쇼핑몰에서 사용할 데이터베이스를 만들려고 합니다. 
-- 사용자는 한 번에 여러 상품을 주문할 수 있고, 여러 번에 걸쳐 주문할 수도 있습니다.
-- 주문이 들어오면 주문 시간과 상품을 기록으로 남기고, 주문이 결제되면 결제 정보도 기록으로 남깁니다.

-- 1. 개념적 데이터 모델링
-- 데이터베이스 전문가 뿐만 아니라 비즈니스 담당자, 최종 사용자 등 누가 보더라도 쉽게 이해할 수 있게 작성

-- draw.io(https://app.diagrams.net/)에 실습

-- 1) 요구사항 분석을 통한 엔티티 선정
-- 사용자, 주문, 상품, 결제

-- 2) 엔티티 간 관계를 화살표와 텍스트로 표시
-- [사용자] -- 주문하다 --> [주문] -- 결제하다 --> [결제]
-- [주문] <-- 장바구니에 담다 --> [상품]

-- 2. 논리적 데이터 모델링
-- 개념적 데이터 모델에 세부 내용을 추가
-- 기술 팀의 판단과 모든 이해 관계자와의 소통과 피드백을 통한 점진적 개선

-- 1) 관계의 카디널리티 구체화
-- 사용자 -> 주문은 선택적 일대다 관계, 주문 -> 사용자는 필수적 일대일 관계
-- 주문 -> 결제는 선택적 일대일 관계, 결제 -> 주문은 필수적 일대일 관계
-- 주문 -> 상품은 필수적 일대다 관계, 상품 -> 주문은 선택적 일대다 관계 

-- 이때 주문과 상품은 다대다 관계

-- 2) 다대다 관계를 위한 중간 엔티티 추가 및 관계 정의
-- 주문과 상품 사이에 주문 상세 엔티티를 추가하고
-- 주문 -> 주문 상세를 필수적 일대다 관계
-- 상품 -> 주문 상세를 선택적 일대다 관계로 연결

-- 3) 엔티티의 속성 구체화 및 PK, FK 선정
-- 각 엔티티를 식별하기 위한 기본키는 PK로 표기
-- 엔티티 간 관계를 연결하기 위한 외래키는 FK로 표기
-- 일반 속성도 요구사항 분석 과정을 통해 추가

-- 3. 물리적 데이터 모델링
-- 논리적 데이터 모델을 특정 DBMS에 맞게 테이블 형태로 구체화
-- 기술 팀이 전문가 관점에서 데이터베이스의 성능과 효율성을 고려해 테이블을 설계

-- 1) 엔티티는 테이블로, 속성은 컬럼으로 변경
-- 각 테이블의 기본키는 id로, 외래키는 XXX_id로 명명해 일관성을 높임

-- 2) 컬럼의 자료형 정의(DBMS에 맞게)
-- 예: MySQL에서 지원하는 자료형 중 해당 컬럼을 가장 잘 저장할 수 있는 것으로 표시

-- (참고) VARCHAR와 ENUM 자료형 선택하기 
-- orders 테이블의 status
-- payments 테이블의 payment_type
-- products 테이블의 product_type
-- 위 컬럼은 모두 VARCHAR로 정의돼 있으나 상황에 따라 ENUM이 더 적절할 수 있음
-- 예를 들어 product_type(상품 유형)이 '냉동', '냉장', '상온'의 3가지 값만 가진다면 ENUM이 좋음 
-- ENUM은 미리 정의한 값 집합에서만 입력을 허용 하기 때문에 데이터의 무결성을 보장하고 빠른 검색 성능을 제공함 
-- 그러나 product_type이 얼마든지 추가되거나 바뀔 수 있는 경우라면 확장성 측면에서 VARCHAR가 유리함
-- 어느 쪽이 유리한지는 DB 설계자가 판단해 적용한다.
-- (그 외 고정 길이 글자이면 CHAR: 우편번호, 국가코드 등)

-- 3) 고유키 및 인덱스 지정
-- users 테이블의 email과 products 테이블의 name을 고유키로 지정
-- 고유키는 UK로 표시
-- products 테이블의 name을 인덱스 처리
-- 상품명으로 검색 및 정렬할 때 성능을 높임

-- 고유키(Unique Key, UK)란 테이블 내에서 값이 고유해야 하는 특정 칼럼 또는 칼럼의 조합을 말함
-- 고유 키로 설정한 칼럼에 중복 값이 입력될 경우 에러가 발생하므로 중복 입력을 예방하려면 고유키로 지정

-- 인덱스(index)는 데이터베이스에서 검색 및 정렬 성능을 최적화하는 데이터 구조로, 
-- 테이블 전체를 스캔하지 않고도 데이터를 효율적으로 찾을 수 있도록 해 줌
-- 인덱스는 두꺼운 책에 끼워 둔 책갈피처럼 데이터를 빠르게 검색할 수 있는 경로를 제공해 
-- 데이터베이스의 검색 성능을 크게 향상시킴
-- MySQL은 기본키(PK), 외래키(FK), 고유키(UK)에 자동으로 인덱스를 생성
-- 인덱스는 검색 및 정렬 성능을 향상시키는 장점도 있지만, 저장 공간을 많이 차지하는 단점도 있음
-- 따라서 인덱스를 생성할 때는 성능과 저장 공간에 따른 비용의 두 요소를 고려해야 함
-- 주로 WHERE 절에 자주 사용되는 컬럼이나 자주 조회하거나 자주 정렬하는 컬럼에만 인덱스를 생성

-- 4. DB 구현하기
-- 물리적 데이터 모델(ER Diagram)을 보고 실제 데이터베이스로 구현
-- 테이블 생성 쿼리를 작성해보자

-- 데이터 모델링(data_modeling) 연습 DB 생성 및 진입
CREATE DATABASE data_modeling;
USE data_modeling;

CREATE TABLE users(
	id INTEGER AUTO_INCREMENT, -- 아이디(자동으로 1씩 증가)
    email VARCHAR(100) NOT NULL UNIQUE, -- 이메일(필수 입력, 고유키 지정)
    name VARCHAR(50) NOT NULL, -- 이름(필수 입력)
    PRIMARY KEY(id) -- 기본키 지정
);

DESC users;
-- orders 테이블 생성
CREATE TABLE orders(
	id INTEGER AUTO_INCREMENT, -- 아이디(자동으로 1씩 증가)
    status VARCHAR(50), -- 주문 상태
    created_at DATETIME, -- 주문 일시
    user_id INTEGER NOT NULL, -- 사용자 아이디(필수 입력) <-- 필수적 일대일 관계 
    PRIMARY KEY(id),
    FOREIGN KEY(user_id) REFERENCES users(id)
);

DESC orders;

-- payments 테이블 생성
CREATE TABLE payments(
	id INTEGER AUTO_INCREMENT, -- 아이디(자동으로 1씩 증가)
    amount INTEGER NOT NULL, -- 결제 금액(필수 입력)
    payment_type VARCHAR(50) NOT NULL, -- 결제 유형(필수 입력)
    order_id INTEGER NOT NULL UNIQUE, -- 주문 아이디 (필수입력, 고유키 지정) <-- 필수적 일대일 관계
    PRIMARY KEY(id),
    FOREIGN key(order_id) REFERENCES orders(id)
);

DESC payments;

-- products 테이블 생성
CREATE TABLE products(
	id INTEGER AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL UNIQUE, -- 기본키를 대신할 수 있는 대체키(기본키의 기본 조건: NOT NULL, UNIQUE)
    price INTEGER NOT NULL CHECK(price > 0), -- 가격(필수입력, 양수만 허용)
    product_type VARCHAR(50) DEFAULT 'NONE', -- 상품 유형(기본값 NONE)
    PRIMARY KEY(id),
    INDEX idx_product_name(name) -- 인덱스 생성: name

);

DESC products;

-- order_details 테이블 생성
CREATE TABLE order_details(
	id INTEGER AUTO_INCREMENT,
    order_id INTEGER NOT NULL, -- 주문 아이디(필수 입력) <-- 필수적 관계
    product_id INTEGER NOT NULL, -- 사용자 아이디(필수 입력) <-- 필수적 관계
    count INTEGER NOT NULL CHECK(count > 0),
    PRIMARY KEY(id),
    FOREIGN KEY(order_id) REFERENCES orders(id),
    FOREIGN KEY(product_id) REFERENCES products(id),
    UNIQUE(order_id, product_id) -- 고유키 지정: order_id, product_id
    -- 하나의 주문에 같은 상품이 중복 담기지 않게 하기 위함
);

DESC order_details;

-- Quiz
-- 4. 다음 빈칸에 들어갈 용어를 순서대로 고르시오. (예: ㄱㄴㄷㄹㅁ)
-- ① __________: 엔티티 간 관계가 필수인지 선택인지를 정의하는 개념
-- ② __________: 칼럼이 NULL 값을 가질 수 없게 하는 제약 조건
-- ③ __________: 칼럼에 입력되는 값이 특정 조건을 만족하도록 하는 제약 조건
-- ④ __________: 칼럼에 값이 입력되지 않을 때 기본으로 저장된 값을 설정하는 제약 조건
-- ⑤ __________: 데이터베이스에서 데이터의 검색 및 정렬 성능을 빠르게 해 주는 데이터 구조로 테이블의 특정 칼럼에 생성해 활용

-- (ㄱ) 인덱스 
-- (ㄴ) CHECK
-- (ㄷ) DEFAULT
-- (ㄹ) 선택성
-- (ㅁ) NOT NULL

-- 정답: ㄹㅁㄴㄷㄱ

/*
	10.4 정규화
*/
-- 데이터 모델링이 잘 되었는지 어떻게 확인할 수 있을까?

-- 정규화(normalization)
-- 데이터 중복 최소화 및 데이터 무결성 보장을 위한 구조화 작업(테이블을 체계적으로 분해하는 과정)
-- 각 단계는 특정 조건을 만족해야 다음 단계로 넘어감
-- • 제1정규형(1NF, First Normal Form)
-- • 제2정규형(2NF, Second Normal Form)
-- • 제3정규형(3NF, Third Normal Form)
-- • 기타 등등등 학술적이거나 특수 목적 시스템에서 사용
-- 일반적으로 정규화는 3단계를 만족하면 충분히 올바른 설계라 할 수 있음

-- (ch10_1NF ~ ch10_3NF.png 참고)

-- 제1정규형
-- 각 속성은 원자값(더 이상 분해할 수 없는 값)이어야 함
-- 중복 컬럼, 반복되는 그룹, 배열 형태, 여러 값이 쉼표로 구분되어 들어 있는 경우 -> 위반
-- | 주문번호 | 고객명 | 상품1  | 상품2  | 상품3  |
-- --------------------------------------------
-- | 1001    | 철수  | 모자    | 신발   | 티셔츠  |
-- | 1002    | 영희  | 가방,후드 | NULL   | NULL   |

-- 제2정규형
-- 제1정규형을 만족해야 함
-- 기본키가 아닌 일반 속성은 기본키의 전체 속성에 의해 결정돼야 함
-- 부분 함수 종속 제거(기본키의 일부분에만 종속된 컬럼 분리)

-- 용어 정리
-- 완전 함수 종속: 일반 속성이 기본키의 전체에 의해 결정 됨
-- 부분 함수 종속: 일반 속성이 기본키의 일부에 의해 결정 됨

-- 제3정규형
-- 제2정규형을 만족해야 함
-- 기본키가 아닌 일반 속성은 다른 일반 속성에 의해 결정되지 않아야 함
-- 이행적 종속 제거 (기본키 이외의 컬럼에 종속된 컬럼 제거)

-- 용어 정리
-- 이행적 함수 종속: 기본키가 아닌 속성이 다른 일반 속성을 결정하는 것

-- Quiz
-- 5. 다음 빈칸에 들어갈 용어를 순서대로 고르시오. (예: ㄱㄴㄷㄹㅁ)
-- ① __________: 데이터의 중복을 최소화하고 데이터 무결성을 보장하기 위해 데이터를 구조화 하는 작업으로, 
--               잘못된 데이터 모델링을 사전에 검증하고 개선하는 것
-- ② __________: 테이블의 칼럼을 더 이상 분해할 수 없도록 나누는 것
-- ③ __________: 일반 속성이 기본키의 전체 속성에 의해 결정되는 것
-- ④ __________: 일반 속성이 기본키의 일부 속성에 의해 결정되는 것
-- ⑤ __________: 일반 속성이 다른 일반 속성에 의해 값이 결정되는 것

-- (ㄱ) 원자화
-- (ㄴ) 이행적 함수 종속
-- (ㄷ) 완전 함수 종속
-- (ㄹ) 부분 함수 종속
-- (ㅁ) 정규화

-- 정답: ㅁㄱㄷㄹㄴ

















